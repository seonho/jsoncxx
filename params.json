{"name":"Jsoncxx","tagline":"jsoncxx is an attempt to create template JSON parser and generator with very simple API.","body":"JSONCXX\r\n=======\r\n\r\n### Introduction\r\n\r\n`JSONCXX` is an attempt to create template JSON parser and generator with very simple API via combining advantages of two famous libraries, [RapidJSON](https://github.com/miloyip/rapidjson) and [JSONCPP](https://github.com/open-source-parsers/jsoncpp).\r\n\r\n### A note\r\n\r\nCurrent version do not fully support JSON specifications.\r\n\r\n### Usage at a glance\r\n\r\nThe `JSONCXX` should be added to your compile include path.\r\n\r\n~~~cpp\r\n#include \"jsoncxx.hpp\"\r\n\r\nint main()\r\n{\r\n    // The contents of glossary.json file can be found fron http://json.org/example\r\n    // parse a JSON file\r\n    jsoncxx::reader reader;\r\n    jsoncxx::value json;\r\n\r\n    if (!reader.parse(\"glossary.json\", json)) {\r\n        std::cerr << \"Failed to open or parse glossary.json\" << std::endl;\r\n        exit(-1);\r\n    }\r\n    \r\n    jsoncxx::value glossary = json[\"glossary\"];\r\n\r\n    // object iterator\r\n    std::cout << \"\\\"glossary\\\" contains ...\" << std::endl;\r\n    std::for_each(glossary.asObject().begin(), glossary.asObject().end(), [&](const std::pair<jsoncxx::value, jsoncxx::value>& elem) {\r\n        std::cout << elem.first << \" : \" << elem.second << std::endl;\r\n    });\r\n\r\n    // object access by name, and string access\r\n    std::cout << \"\\\"title\\\" is \" << glossary[\"title\"].asString() << std::endl;\r\n\r\n    // array access \r\n    jsoncxx::value seealso = glossary[\"GlossDiv\"][\"GlossList\"][\"GlossEntry\"][\"GlossDef\"][\"GlossSeeAlso\"];\r\n    std::cout << \"0th element of \\\"GlossSeeAlso\\\" is \" << seealso[0] << std::endl;\r\n    \r\n    // array iterator\r\n    std::cout << \"\\\"GlossSeeAlso\\\" contains ...\" << std::endl;\r\n    std::for_each(seealso.asArray().begin(), seealso.asArray().end(), [&](const jsoncxx::value& elem) { std::cout << elem << std::endl; });\r\n    \r\n    // natural or real number type\r\n    glossary[\"number\"][\"natural\"] = 1234;\r\n    glossary[\"number\"][\"real\"] = 3.14159265359;\r\n\r\n    std::cout << \"number types :\" << glossary[\"number\"] << std::endl;\r\n\r\n    // boolean type\r\n    glossary[\"boolean\"] = true;\r\n    std::cout << \"boolean type : \" << glossary[\"boolean\"] << std::endl;\r\n\r\n    // null type\r\n    glossary[\"nothing\"];\r\n    std::cout << \"If nothing specified, then type would be null type and value is \" << glossary[\"nothing\"] << std::endl;\r\n\r\n    std::ofstream fout(\"save.json\");\r\n    fout << glossary;\r\n    fout.close();\r\n\r\n    // implicit casting\r\n    jsoncxx::value::string str = glossary[\"title\"];\r\n    jsoncxx::natural natural = glossary[\"number\"][\"natural\"];\r\n    jsoncxx::real    real    = glossary[\"number\"][\"real\"];\r\n\r\n    // explicit casting for bool type\r\n    bool boolean = (bool)glossary[\"boolean\"];\r\n\r\n    // initializer_list example\r\n    glossary[\"array\"] = { 1, 3.141592, true, \"a string\"};\r\n\r\n    return 0;\r\n}\r\n~~~\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}